package state

import (
	"fmt"
	"log/slog"
	"sync"
	"time"

	"github.com/petrock/example_module_path/core" // Placeholder for target project's core package
)

// State holds the collective in-memory state for the feature.
// It's built by replaying logged messages and updated by command handlers.
type State struct {
	Items map[string]*Item // Map from Item ID to the Item object pointer
	mu    sync.RWMutex     // Protects concurrent access to Items map
}

// NewState creates an initialized (empty) State.
func NewState() *State {
	return &State{
		Items: make(map[string]*Item),
	}
}

// Apply updates the state based on a logged message (typically a command).
// This is the core logic for state reconstruction during replay and updates during runtime.
// Note: This example assumes commands are logged directly. If events are logged,
// the logic here would react to event types instead.
// Commands MUST be passed as pointer types (*CommandType).
// The msg parameter is non-nil during replay (providing timestamp and ID) and nil during direct execution.
func (s *State) Apply(payload interface{}, msg *core.Message) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	switch cmd := payload.(type) {
	case *CreateCommand:
		// Check if item already exists (optional, depends on desired idempotency)
		if _, exists := s.Items[cmd.Name]; exists { // Assuming Name is used as ID for creation simplicity
			slog.Warn("Attempted to create already existing item", "id", cmd.Name)
			return fmt.Errorf("item with name %s already exists", cmd.Name) // Or return nil for idempotency
		}
		newItem := &Item{
			ID:          cmd.Name, // Use Name as ID for simplicity, replace with generated ID if needed
			Name:        cmd.Name,
			Description: cmd.Description,
			// Example content that would need summarization
			Content:   "This is a sample longer content that would need summarization. Imagine this is a blog post, article, or other lengthy text that would benefit from having a concise summary generated by an AI service or algorithm.",
			CreatedAt: getTimestamp(msg), // Use message timestamp if available, otherwise current time
			UpdatedAt: getTimestamp(msg),
			Version:   1,
		}
		s.Items[newItem.ID] = newItem
		slog.Debug("Applied CreateCommand to state", "id", newItem.ID)

	case *UpdateCommand:
		existingItem, found := s.Items[cmd.ID]
		if !found {
			slog.Warn("Attempted to update non-existent item", "id", cmd.ID)
			return fmt.Errorf("item with ID %s not found for update", cmd.ID) // Or handle as upsert
		}
		existingItem.Name = cmd.Name
		existingItem.Description = cmd.Description
		existingItem.UpdatedAt = getTimestamp(msg) // Use message timestamp if available, otherwise current time
		existingItem.Version++
		slog.Debug("Applied UpdateCommand to state", "id", existingItem.ID, "version", existingItem.Version)

	case *DeleteCommand:
		if _, found := s.Items[cmd.ID]; !found {
			slog.Warn("Attempted to delete non-existent item", "id", cmd.ID)
			return fmt.Errorf("item with ID %s not found for deletion", cmd.ID) // Or return nil for idempotency
		}
		delete(s.Items, cmd.ID) // Hard delete for this example
		slog.Debug("Applied DeleteCommand to state", "id", cmd.ID)

	case *SetGeneratedSummaryCommand:
		existingItem, found := s.Items[cmd.ID]
		if !found {
			slog.Warn("Attempted to set summary for non-existent item", "id", cmd.ID)
			return fmt.Errorf("item with ID %s not found for summary update", cmd.ID)
		}
		// Set the summary
		existingItem.Summary = cmd.Summary
		existingItem.UpdatedAt = getTimestamp(msg)
		existingItem.Version++
		slog.Debug("Applied SetGeneratedSummaryCommand to state", "id", cmd.ID, "version", existingItem.Version)

	default:
		// This might happen if the message log contains message types not handled here
		// (e.g., events if event sourcing is used, or other command types).
		slog.Warn("Apply received unhandled message type", "type", fmt.Sprintf("%T", msg))
		// Decide whether to return an error or just ignore
		// return fmt.Errorf("unhandled message type in State.Apply: %T", msg)
	}

	return nil
}

// getTimestamp returns the timestamp from the message metadata if available, otherwise current time
func getTimestamp(msg *core.Message) time.Time {
	if msg != nil {
		return msg.Timestamp
	}
	return time.Now().UTC()
}

// --- Helper to register types with the message log ---

// RegisterTypes registers the message types used by this feature's state Apply method.
// This should be called during application initialization where the message log is configured.
func RegisterTypes(log *core.MessageLog) {
	// Register command types as pointers since CommandName has pointer receivers
	log.RegisterType(&CreateCommand{})
	log.RegisterType(&UpdateCommand{})
	log.RegisterType(&DeleteCommand{})
	log.RegisterType(&RequestSummaryGenerationCommand{})
	log.RegisterType(&FailSummaryGenerationCommand{})
	log.RegisterType(&SetGeneratedSummaryCommand{})
	// Register any event types here if using event sourcing and Apply reacts to events
}
